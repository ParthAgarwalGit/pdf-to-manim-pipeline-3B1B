"""Output manifest schema for Persistence Agent."""

from datetime import datetime
from typing import List

from pydantic import BaseModel, ConfigDict, Field, field_validator, model_validator


class OutputFile(BaseModel):
    """Information about a single output file."""
    
    path: str = Field(
        ...,
        description="Path to the file relative to output_directory"
    )
    size_bytes: int = Field(
        ...,
        ge=0,
        description="File size in bytes"
    )
    type: str = Field(
        ...,
        description="File type (animation_code|narration_script|storyboard|manifest|report)"
    )
    
    @field_validator('type')
    @classmethod
    def validate_type(cls, v: str) -> str:
        """Validate file type is one of the allowed values."""
        allowed_types = {
            'animation_code',
            'narration_script',
            'storyboard',
            'manifest',
            'report',
            'ocr_output',
            'log'
        }
        if v not in allowed_types:
            raise ValueError(
                f"type must be one of {allowed_types}, got '{v}'"
            )
        return v


class FailedSceneManifest(BaseModel):
    """Information about a scene that failed to generate."""
    
    scene_id: str = Field(..., description="Unique identifier for the failed scene")
    error: str = Field(..., description="Error message describing the failure")


class OutputManifest(BaseModel):
    """
    Complete manifest of all output files generated by the pipeline.
    
    Written by Persistence Agent to manifest.json in the output directory.
    """
    
    output_directory: str = Field(
        ...,
        description="Absolute path to the output directory"
    )
    files: List[OutputFile] = Field(
        ...,
        description="Array of all generated files with metadata"
    )
    timestamp: datetime = Field(
        ...,
        description="ISO8601 timestamp when the manifest was created"
    )
    status: str = Field(
        ...,
        description="Overall pipeline status (SUCCESS|PARTIAL_SUCCESS|FAILURE|CRITICAL_FAILURE)"
    )
    scene_success_rate: float = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Fraction of scenes that generated successfully (0-1)"
    )
    total_scenes: int = Field(
        ...,
        ge=0,
        description="Total number of scenes in the storyboard"
    )
    successful_scenes: int = Field(
        ...,
        ge=0,
        description="Number of scenes that generated successfully"
    )
    failed_scenes: List[FailedSceneManifest] = Field(
        default_factory=list,
        description="Array of scenes that failed to generate"
    )
    
    @field_validator('status')
    @classmethod
    def validate_status(cls, v: str) -> str:
        """Validate status is one of the allowed values."""
        allowed_statuses = {'SUCCESS', 'PARTIAL_SUCCESS', 'FAILURE', 'CRITICAL_FAILURE'}
        if v not in allowed_statuses:
            raise ValueError(
                f"status must be one of {allowed_statuses}, got '{v}'"
            )
        return v
    
    @field_validator('successful_scenes')
    @classmethod
    def validate_successful_scenes(cls, v: int, info) -> int:
        """Ensure successful_scenes does not exceed total_scenes."""
        total = info.data.get('total_scenes', 0)
        if v > total:
            raise ValueError(
                f"successful_scenes ({v}) cannot exceed total_scenes ({total})"
            )
        return v
    
    @model_validator(mode='after')
    def validate_scene_success_rate_consistency(self) -> 'OutputManifest':
        """Ensure scene_success_rate is consistent with successful/total scenes."""
        if self.total_scenes == 0:
            expected_rate = 0.0
        else:
            expected_rate = self.successful_scenes / self.total_scenes
        
        # Allow small floating point differences
        if abs(self.scene_success_rate - expected_rate) > 0.001:
            raise ValueError(
                f"scene_success_rate ({self.scene_success_rate}) is inconsistent with "
                f"successful_scenes ({self.successful_scenes}) / total_scenes ({self.total_scenes}) = {expected_rate}"
            )
        return self
    
    @field_validator('output_directory')
    @classmethod
    def validate_output_directory(cls, v: str) -> str:
        """Ensure output_directory is not empty."""
        if not v or not v.strip():
            raise ValueError("output_directory cannot be empty")
        return v
    
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "output_directory": "/path/to/output/linear_algebra/2024-01-15T10-30-00",
                "files": [
                    {
                        "path": "scene_intro_001.py",
                        "size_bytes": 2048,
                        "type": "animation_code"
                    },
                    {
                        "path": "narration_script.txt",
                        "size_bytes": 5120,
                        "type": "narration_script"
                    },
                    {
                        "path": "storyboard.json",
                        "size_bytes": 10240,
                        "type": "storyboard"
                    },
                    {
                        "path": "processing_report.json",
                        "size_bytes": 1024,
                        "type": "report"
                    },
                    {
                        "path": "manifest.json",
                        "size_bytes": 2048,
                        "type": "manifest"
                    }
                ],
                "timestamp": "2024-01-15T10:35:00Z",
                "status": "SUCCESS",
                "scene_success_rate": 1.0,
                "total_scenes": 10,
                "successful_scenes": 10,
                "failed_scenes": []
            }
        }
    )
